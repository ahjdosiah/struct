# å“ˆå¤«æ›¼æ ‘ å“ˆå¤«æ›¼ç¼–ç 

## å‰è¨€

å“ˆå¤«æ›¼æ ‘ä¹Ÿæœ‰äººç§°ä¸º éœå¤«æ›¼æ ‘ æˆ– æœ€ä¼˜äºŒå‰æ ‘ã€‚

å“ˆå¤«æ›¼ï¼ˆDavid Huffmanï¼‰æ˜¯ç¾å›½çš„ä¸€ä½æ•°å­¦å®¶ã€‚ä»–åœ¨ 1952 å¹´å‘æ˜äº†å“ˆå¤«æ›¼ç¼–ç ï¼ˆä¸€ç§äºŒè¿›åˆ¶ç¼–ç ï¼‰ï¼Œè¯¥ç¼–ç ä¸­ç”¨åˆ°äº†ä¸€ç§ç‰¹æ®Šçš„äºŒå‰æ ‘ï¼Œäººä»¬ä¸ºäº†çºªå¿µä»–çš„æˆå°±ï¼Œå°†æ‰€ç”¨åˆ°çš„ç‰¹æ®ŠäºŒå‰æ ‘ç§°ä¸ºå“ˆå¤«æ›¼æ ‘ã€‚



## åŸºæœ¬æœ¯è¯­

- è·¯å¾„å’Œè·¯å¾„é•¿åº¦

  åœ¨ä¸€æ£µæ ‘ä¸­ï¼Œä»ä¸€ä¸ªç»“ç‚¹å¾€ä¸‹å¯ä»¥è¾¾åˆ°çš„å­©å­æˆ–å­™å­ç»“ç‚¹ä¹‹é—´çš„é€šè·¯ï¼Œç§°ä¸ºè·¯å¾„ã€‚å¦‚æ ¹èŠ‚ç‚¹åˆ°a

  é€šè·¯ä¸­åˆ†æ”¯çš„æ•°ç›®ç§°ä¸ºè·¯å¾„é•¿åº¦ã€‚è‹¥è§„å®šæ ¹ç»“ç‚¹çš„å±‚æ•°ä¸º1ï¼Œåˆ™ä»æ ¹ç»“ç‚¹åˆ°ç¬¬Lå±‚ç»“ç‚¹çš„è·¯å¾„é•¿åº¦ä¸ºL-1ã€‚aä¸ºç¬¬äºŒå±‚

- ç»“ç‚¹çš„æƒå’Œç»“ç‚¹çš„å¸¦æƒè·¯å¾„é•¿åº¦

  è‹¥å°†æ ‘ä¸­ç»“ç‚¹èµ‹ç»™ä¸€ä¸ªæœ‰ç€æŸç§å«ä¹‰çš„æ•°å€¼ï¼Œåˆ™è¿™ä¸ªæ•°å€¼ç§°ä¸ºè¯¥ç»“ç‚¹çš„æƒã€‚açš„æƒä¸º7

  ç»“ç‚¹çš„å¸¦æƒè·¯å¾„é•¿åº¦ä¸ºï¼šä»æ ¹ç»“ç‚¹åˆ°è¯¥ç»“ç‚¹ä¹‹é—´çš„è·¯å¾„é•¿åº¦ä¸è¯¥ç»“ç‚¹çš„æƒçš„ä¹˜ç§¯ã€‚bçš„å¸¦æƒè·¯å¾„é•¿åº¦ 5*2 = 10

- æ ‘çš„å¸¦æƒç»“ç‚¹é•¿åº¦ï¼ˆWPLï¼‰

  æ ‘çš„å¸¦æƒè·¯å¾„é•¿åº¦è§„å®šä¸ºæ‰€æœ‰å¶å­ç»“ç‚¹çš„å¸¦æƒè·¯å¾„é•¿åº¦ä¹‹å’Œ
  $$
  WPL = 7*1 + 5*2+2*3+4*3
  $$

![](D:\è½¯ä»¶\typora\Typora\image\hfm_tree\09563Tb0-0.png)

## å“ˆå¤«æ›¼æ ‘çš„åŸºæœ¬æ„é€ 

å¯¹äºç»™å®šçš„æœ‰å„è‡ªæƒå€¼çš„ n ä¸ªç»“ç‚¹ï¼Œæ„å»ºå“ˆå¤«æ›¼æ ‘æœ‰ä¸€ä¸ªè¡Œä¹‹æœ‰æ•ˆçš„åŠæ³•ï¼š

1. åœ¨ n ä¸ªæƒå€¼ä¸­é€‰å‡ºä¸¤ä¸ªæœ€å°çš„æƒå€¼ï¼Œå¯¹åº”çš„ä¸¤ä¸ªç»“ç‚¹ç»„æˆä¸€ä¸ªæ–°çš„äºŒå‰æ ‘ï¼Œä¸”æ–°äºŒå‰æ ‘çš„æ ¹ç»“ç‚¹çš„æƒå€¼ä¸ºå·¦å³å­©å­æƒå€¼çš„å’Œï¼›
2. åœ¨åŸæœ‰çš„ n ä¸ªæƒå€¼ä¸­åˆ é™¤é‚£ä¸¤ä¸ªæœ€å°çš„æƒå€¼ï¼ŒåŒæ—¶å°†æ–°çš„æƒå€¼åŠ å…¥åˆ° nâ€“2 ä¸ªæƒå€¼çš„è¡Œåˆ—ä¸­ï¼Œä»¥æ­¤ç±»æ¨ï¼›
3. é‡å¤ 1 å’Œ 2 ï¼Œç›´åˆ°æ‰€ä»¥çš„ç»“ç‚¹æ„å»ºæˆäº†ä¸€æ£µäºŒå‰æ ‘ä¸ºæ­¢ï¼Œè¿™æ£µæ ‘å°±æ˜¯å“ˆå¤«æ›¼æ ‘ã€‚														![](D:\è½¯ä»¶\typora\Typora\image\hfm_tree\09563QS5-1-1699877296837-3.png) 
   

ä¸Šå›¾ ä¸­ï¼Œï¼ˆAï¼‰ç»™å®šäº†å››ä¸ªç»“ç‚¹aï¼Œbï¼Œcï¼Œdï¼Œæƒå€¼åˆ†åˆ«ä¸º7ï¼Œ5ï¼Œ2ï¼Œ4ï¼›ç¬¬ä¸€æ­¥å¦‚ï¼ˆBï¼‰æ‰€ç¤ºï¼Œæ‰¾å‡ºç°æœ‰æƒå€¼ä¸­æœ€å°çš„ä¸¤ä¸ªï¼Œ2 å’Œ 4 ï¼Œç›¸åº”çš„ç»“ç‚¹ c å’Œ d æ„å»ºä¸€ä¸ªæ–°çš„äºŒå‰æ ‘ï¼Œæ ‘æ ¹çš„æƒå€¼ä¸º 2 + 4 = 6ï¼ŒåŒæ—¶å°†åŸæœ‰æƒå€¼ä¸­çš„ 2 å’Œ 4 åˆ æ‰ï¼Œå°†æ–°çš„æƒå€¼ 6 åŠ å…¥ï¼›è¿›å…¥ï¼ˆCï¼‰ï¼Œé‡å¤ä¹‹å‰çš„æ­¥éª¤ã€‚ç›´åˆ°ï¼ˆDï¼‰ä¸­ï¼Œæ‰€æœ‰çš„ç»“ç‚¹æ„å»ºæˆäº†ä¸€ä¸ªå…¨æ–°çš„äºŒå‰æ ‘ï¼Œè¿™å°±æ˜¯å“ˆå¤«æ›¼æ ‘ã€‚

## ä»£ç éƒ¨åˆ†

### å“ˆå¤«æ›¼æ ‘çš„ç»“ç‚¹

```c++
struct HFMTreeNode{
	string code;//å“ˆå¤«æ›¼ç¼–ç 
	char op;//ç¼–ç å¯¹åº”çš„å­—ç¬¦
	int weight; //æƒå€¼
	int parent; //çˆ¶äº²ï¼ˆæ•°ç»„ä¸‹æ ‡å€¼ï¼‰
	int lchild; //å·¦å­©å­
	int rchild; //å³å­©å­
};
```

### å“ˆå¤«æ›¼æ ‘ç±»

å¤§çº²

```c++
class HFMTree{
private:
	HFMTreeNode* m_data;//å“ˆå¤«æ›¼æ ‘å‚¨å­˜æ•°ç»„
	map<char,string>code;//ä¿å­˜å­—ç¬¦å¯¹åº”çš„äºŒè¿›åˆ¶ç¼–ç 
	int m_length; //è®°å½•å½“å‰æ ‘æœ‰å¤šå°‘ä¸ªèŠ‚ç‚¹ã€æ•°ç»„ä¸­å¤šå°‘ä¸ªèŠ‚ç‚¹è¢«ä½¿ç”¨äº†ã€‘
	
	void SelectTwoMinValue(int& rtnIdx1, int& rtnIdx2);//é€‰æ‹©å„èŠ‚ç‚¹ä¸­æƒå€¼æœ€å°çš„ä¸¤ä¸ª
	void preOrderLeaf(int idx,char* op,int op_size);//å…ˆåºéå†å¶å­ç»“ç‚¹ï¼Œå¹¶è¾“å‡ºå¯¹åº”çš„å­—ç¬¦ï¼Œå‡ºç°æ¬¡æ•°ï¼Œå¯¹åº”ç¼–ç 

	void ShowTree(int idx,map<char,int>count,char* op,int op_size,string way);//å‘ˆæ ‘å½¢è¾“å‡ºå“ˆå¤«æ›¼æ ‘
	
    //å¯¹ç¼–ç è¿›è¡Œè§£ç 
	string decode(int idx, const string& code);
	string::const_iterator decode(int idx, string::const_iterator codeBegin, string::const_iterator codeEnd, string& result);
	
public:
	~HFMTree(){ //ææ„å‡½æ•°
		delete[] m_data;
	}
	HFMTree(int nodecount, int* pweight);
	void CreateHFMTree();//æ„é€ å“ˆå¤«æ›¼æ ‘
	
	int GetLength(){//è·å–m_length
		return m_length;
	}
	
	void preOrderLeaf(char* op,int op_size){
		preOrderLeaf(this->GetLength()-1,op,op_size);
	}
	void ShowTree(map<char,int>count,char* op,int op_size){
		ShowTree(this->GetLength()-1,count,op,op_size,"");
	}
	//å¯¹å­—ç¬¦ä¸²è¿›è¡ŒåŠ å¯†
	string encode(const string str){
        string coding = "";
        for (unsigned int i = 0; i < str.length(); i++)
            coding += this->code[str.at(i)];
        return coding;
    }
	string decode(const string& code){
		return decode(this->GetLength()-1,code);
	}
};
```

### å„å‡½æ•°å…·ä½“å®ç°

#### HFMTree()

å‚æ•°è§£é‡Šï¼šnodecountï¼š pweight[]ä¸­çš„å€¼çš„ä¸ªæ•°

â€‹					pweight[]ï¼šæ„å»ºå“ˆå¤«æ›¼æ ‘éœ€è¦çš„ç»“ç‚¹çš„æƒå€¼

å…ˆç»™m_dataåˆ†é…è¶³å¤Ÿçš„ç©ºé—´ï¼ˆå¯ä»¥å®¹çº³ä¸‹æœ€åˆçš„ç»“ç‚¹å’Œæœ€ç»ˆçš„å“ˆå¤«æ›¼æ ‘ï¼‰ã€‚ä¹‹åé€šè¿‡å¾ªç¯ï¼Œå°†æœ€åˆçš„ç»“ç‚¹åˆ†é…è¿›m_dataä¸­

~~~c++
HFMTree(int nodecount, int* pweight){
		code['0'] = "";
		m_length = nodecount; //èŠ‚ç‚¹ä¸ªæ•°
		int iMaxNodeCount = 2 * m_length - 1; //å“ˆå¤«æ›¼æ ‘çš„èŠ‚ç‚¹æ€»æ•°æ˜¯2n-1ï¼ˆnä»£è¡¨å“ˆå¤«æ›¼æ ‘çš„å¶å­èŠ‚ç‚¹æ•°é‡ï¼‰
		m_data = new HFMTreeNode[iMaxNodeCount]; //2n-1ä¸ªèŠ‚ç‚¹çš„å“ˆå¤«æ›¼æ•°ç»„
	
		for (int i = 0; i < iMaxNodeCount; ++i)
		{
			//-1æ ‡è®°æœªè¢«ä½¿ç”¨
			m_data[i].code = "";
			m_data[i].op = '0';
			m_data[i].parent = -1;
			m_data[i].lchild = -1;
			m_data[i].rchild = -1;
		}
		for (int i = 0; i < m_length; ++i)
		{
			m_data[i].weight = pweight[i];
		}
	}
~~~

å‡è®¾ `nodecount = 5` `pweight[] = {1ï¼Œ2ï¼Œ4}`ï¼Œåˆ™ï¼Œå‡½æ•°å…ˆç”¨m_lengthå‚¨å­˜nodecountçš„å€¼ï¼Œå†ç»™m_dataåˆ†é… 2*m_length-1çš„ç©ºé—´ã€‚ç»™å“ˆå¤«æ›¼æ ‘æ¯ä¸ªç»“ç‚¹éƒ½åˆå§‹åŒ–ã€‚ç„¶åç»™å¶å­ç»“ç‚¹ï¼ˆåˆå§‹ç»“ç‚¹ï¼‰èµ‹å€¼ï¼Œå³å°†pweigth[]çš„å€¼èµ‹ç»™ç›¸åº”çš„å¶å­ç»“ç‚¹

| ç¼–å· | weight | parent | lchild | rchile |
| ---- | ------ | ------ | ------ | ------ |
| 0    | 1      | -1     | -1     | -1     |
| 1    | 2      | -1     | -1     | -1     |
| 2    | 4      | -1     | -1     | -1     |
| 3    |        | -1     | -1     | -1     |
| 4    |        | -1     | -1     | -1     |



#### SelectTwoMinValue()

å‚æ•°è§£é‡Šï¼šä¸¤ä¸ªå¼•ç”¨ï¼Œç”¨äºä¼ å‡ºæœ€å°ä¸¤ä¸ªæƒå€¼æ‰€å¯¹åº”çš„æ•°ç»„ä¸‹æ ‡

é€šè¿‡å¾ªç¯ï¼Œæ‰¾å‡ºæ•°ç»„ä¸­ä¸¤ä¸ªè¿˜æœªè¢«ä½¿ç”¨çš„ç»“ç‚¹ï¼Œåˆ†åˆ«ä¼ å›æœ€å°å’Œç¬¬äºŒå°çš„æƒå¯¹åº”çš„ç»“ç‚¹çš„ä¸‹æ ‡

ä¸»è¦ä½œç”¨æ˜¯åœ¨==CreatHFMTree()==å‡½æ•°ä¸­æ‰¾å‡ºæœ€å°çš„ä¸¤ä¸ªç»“ç‚¹ï¼Œç»„æˆè¾ƒå°çš„äºŒå‰æ ‘

~~~c
void SelectTwoMinValue(int& rtnIdx1, int& rtnIdx2){
		int minval1 = INT_MAX;//INT_MAXæ˜¯è‡ªå¸¦çš„intç±»æœ€å¤§å€¼
		int minval2 = INT_MAX;
	
		//æ‰¾æœ€å°å€¼
		for (int i = 0; i < m_length; ++i)
		{
			if (m_data[i].parent == -1) //çˆ¶æ ‡è®°æœªè¢«ä½¿ç”¨
			{
				if (minval1 > m_data[i].weight)
				{
					minval1 = m_data[i].weight; //è®°å½•æœ€å°å€¼
					rtnIdx1 = i; //è®°å½•ä¸‹æ ‡
				}
			}
		} 
	
		//æ‰¾ç¬¬äºŒä¸ªæœ€å°çš„å€¼
		for (int i = 0; i < m_length; ++i)
		{
			if (m_data[i].parent == -1 && i != rtnIdx1) //æ³¨æ„&&åçš„æ¡ä»¶ï¼Œç›®çš„æ˜¯æŠŠç¬¬ä¸€ä¸ªæ‰¾åˆ°çš„æœ€å°æƒå€¼çš„èŠ‚ç‚¹æ’é™¤
			{
				if (minval2 > m_data[i].weight)
				{
					minval2 = m_data[i].weight; //è®°å½•æœ€å°å€¼
					rtnIdx2 = i; //è®°å½•ä¸‹æ ‡
				}
			}
		}
		return;
	}
~~~

#### CreateHFMTree()

åŒå“ˆå¤«æ›¼æ ‘çš„åŸºæœ¬æ„é€ ï¼Œæ¯æ¬¡æ‰¾æœ€å°çš„ä¸¤ä¸ªç»“ç‚¹ï¼Œç»“æˆä¸€ä¸ªæ–°çš„äºŒå‰æ ‘ï¼Œç»™æ–°äºŒå‰æ ‘çš„æ›´æ–°ç»“ç‚¹ï¼Œå’Œæ›´æ”¹m_lengthçš„å€¼ï¼Œå¢åŠ SelectTwoMinValue()èƒ½è®¿é—®çš„èŒƒå›´

~~~c++
void CreateHFMTree(){
		int idx1 = 0;
		int idx2 = 0;
		
		int iMaxNodeCount = 2 * m_length - 1; //2n-1æ˜¯æ•´ä¸ªå“ˆå¤«æ›¼æ ‘çš„èŠ‚ç‚¹æ•°é‡
		int initlength = m_length;
		for (int i = initlength; i < iMaxNodeCount; ++i)
		{
			SelectTwoMinValue(idx1, idx2);
			m_data[i].weight = m_data[idx1].weight + m_data[idx2].weight; //æ–°èŠ‚ç‚¹çš„æƒå€¼ç­‰äºå·¦å³å­©å­
			m_data[i].lchild = idx1;
			m_data[i].rchild = idx2;
			m_data[i].op = '0';
			m_data[idx1].parent = i;
			m_data[idx2].parent = i;

			m_length++; //SelectTwoMinValue()å‡½æ•°è¦ç”¨åˆ°è¯¥å€¼
		}
		return;
	}
~~~

| ç¼–å· | weight | parent | lchild | rchile |
| ---- | ------ | ------ | ------ | ------ |
| 0    | 1      | 3      | -1     | -1     |
| 1    | 2      | 3      | -1     | -1     |
| 2    | 4      | 4      | -1     | -1     |
| 3    | 3      | 4      | 0      | 1      |
| 4    | 7      | -1     | 3      | 2      |

#### ShowTree()

è¿™ä¸ªå‡½æ•°æœ‰ä¸¤ä¸ªé‡è½½å‡½æ•°ï¼Œåˆ†åˆ«æ˜¯å…¬æœ‰çš„==ShowTree(map<char,int>count,char* op,int op_size)==å’Œç§æœ‰çš„==ShowTree(int idx,map<char,int>count,char* op,int op_size,string way)==ã€‚

å…¬æœ‰çš„å‡½æ•°ä½“åªæœ‰ä¸€è¡Œï¼Œç”¨äºè°ƒç”¨ç§æœ‰çš„ShowTree()å‡½æ•°ï¼Œåœ¨ä¸»å‡½æ•°ä¸­ä¸éœ€è¦å¤æ‚çš„ä¼ å‚ã€‚

~~~c++
void ShowTree(map<char,int>count,char* op,int op_size){
		ShowTree(this->GetLength()-1,count,op,op_size,"");
	}
~~~

ç§æœ‰çš„å‡½æ•°æ˜¯è¿™ä¸ªå‡½æ•°çš„ä¸»è¦å®ç°ã€‚ä¸»è¦æœ‰ä¸¤ä¸ªåŠŸèƒ½ï¼Œ**è¾“å‡ºå“ˆå¤«æ›¼æ ‘**ï¼Œ**å¯¹ç»“ç‚¹çš„codeå’Œopè¿›è¡Œæ›´æ–°**ã€‚

è¾“å‡ºéœ€è¦å€ŸåŠ©è¿™å‡ ä¸ªå…¨å±€å˜é‡å’Œå®å®šä¹‰

~~~c++
#define RIGHT '0'
#define LEFT '1'
string up_right = "â”Œ";
string down_right = "â””";
string up_left = "â”";
string down_left = "â”˜";
string T_cross = "â”¤";
string line = "â”‚";
~~~

å‚æ•°è§£é‡Šï¼šidxï¼šéœ€è¦è¾“å‡ºç»“ç‚¹çš„ä¸‹æ ‡

â€‹					countï¼šåœ¨ä¸»å‡½æ•°ä¸­æ˜¯è®¡ç®—åœ¨å­—ç¬¦ä¸²ä¸­æ¯ä¸ªå­—ç¬¦å‡ºç°çš„æ¬¡æ•°ï¼Œè¿™é‡Œç”¨äºåŒ¹é…ç»“ç‚¹çš„æƒå€¼å¯¹åº”å“ªä¸ªå­—ç¬¦å‡ºç°çš„æ¬¡æ•°

â€‹					op[]ï¼šè®°å½•ä¸»å‡½æ•°ä¸­å­—ç¬¦ä¸²ä¸­å‡ºç°è¿‡çš„å­—ç¬¦

â€‹					op_sizeï¼šopçš„é•¿åº¦

â€‹					wayï¼šè¡¨ç¤ºè¾¾åˆ°è¯¥èŠ‚ç‚¹èµ°è¿‡çš„è·¯ï¼Œä»æ ¹å¼€å§‹ï¼Œå‘å³æ˜¯'0'ï¼Œå‘å·¦æ˜¯'1'ï¼Œå¹¶æ›´æ–°è‡³å¯¹åº”çš„å¶å­ç»“ç‚¹

è¯¥å‡½æ•°å…ˆåˆ¤æ–­ç»“ç‚¹æ˜¯å¦æœ‰å³å­©å­ï¼Œå¦‚æœæœ‰ï¼Œå°±æ›´æ–°wayå¹¶å±•ç¤ºå³å­©å­ã€‚æ²¡æœ‰åˆ™ç»§ç»­ï¼Œå¯¹åº”ç»“ç‚¹çš„codeæ›´æ–°ä¸ºwayã€‚ç„¶åè¾“å‡ºè¯¥ç»“ç‚¹ã€‚è¾“å‡ºå®Œæƒå€¼åï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºå¶å­ç»“ç‚¹ï¼Œå¦‚æœæ˜¯ï¼Œæ›´æ–°å…¶opã€‚æœ€åï¼Œå¦‚æœæœ‰å·¦å­©å­ï¼Œåˆ™æ›´æ–°wayï¼Œå±•ç¤ºå·¦å­©å­

~~~c++
void ShowTree(int idx,map<char,int>count,char* op,int op_size,string way){ 
    // wayè¡¨ç¤ºè¾¾åˆ°è¯¥èŠ‚ç‚¹èµ°è¿‡çš„è·¯ï¼Œä»æ ¹å¼€å§‹ï¼Œå‘å³æ˜¯'0'ï¼Œå‘å·¦æ˜¯'1'
		if (m_data[idx].rchild != -1)
		{
			string right_way = way + RIGHT;
			ShowTree(m_data[idx].rchild,count,op,op_size, right_way);
		}
		this->m_data[idx].code = way;
		string pre;            // æ‰“å°èŠ‚ç‚¹å‰éœ€è¦è¾“å‡ºçš„å‰ç½®æ•°æ®
		if (way.length() == 0) // æ ¹èŠ‚ç‚¹ï¼Œä¸è€ƒè™‘å‰ç½®è¾“å‡ºï¼Œè¿™é‡Œè¾“å‡ºä¸€ä¸ªç©ºæ ¼
			pre = " ";
		else
		{
			pre = "   ";  // è¿™ä¸‰ä¸ªç©ºæ ¼æ¥è‡ªæ ¹èŠ‚ç‚¹é‚£ä¸€å±‚
			for (unsigned int i = 1; i < way.length(); i++)
			{
				// æŒ‰ç…§å¼‚æˆ–å…³ç³»è¡¥å…¨å‰ç½®è¾“å‡º
				if (way.at(i) != way.at(i - 1))
				{
					pre += line;
					pre += "  ";
				}
				else
				{
					pre += "   ";
				}
			}
			int l = way.length();
			// æ ¹æ®æœ€åä¸€æ¬¡è½¬å¼¯æ–¹å‘é€‰æ‹©æ•°å­—å‰é¢çš„ç¬¦å·
			if (way.at(l - 1) == '0')
				pre += up_right;
			else
				pre += down_right;
		}
		
		cout << pre << setw(2) << m_data[idx].weight;
		// æ ¹æ®å·¦å³å­æ ‘æƒ…å†µä¸ºä¸‹ä¸€å±‚ç•™ä¸‹åˆ†å‰æ ‡å¿—
		if (m_data[idx].lchild != -1 && m_data[idx].rchild != -1)
			cout << T_cross;
		else if (m_data[idx].lchild != -1 && m_data[idx].rchild == -1)
			cout << up_left;
		else if (m_data[idx].lchild == -1 && m_data[idx].rchild != -1)
			cout << down_left;
		else{
			for(int i = 0; i < op_size ; i++){
				if(m_data[idx].weight == count[op[i]]){
					m_data[idx].op = op[i];
					op[i] = '0';
					break;
				}
			}
			if(m_data[idx].op == ' ')
				cout << " " << "space";
			else
				cout << " " << m_data[idx].op;
		}
			 
		cout << endl;
		
		if (m_data[idx].lchild != -1)
		{
			string left_way = way + LEFT;
			ShowTree(m_data[idx].lchild,count,op,op_size, left_way);
		}
	}
~~~

å‡è®¾ä¸»å‡½æ•°ä¸­çš„å­—ç¬¦ä¸²ä¸º`abbcccc`,åˆ™`count[a]=1 count[b]=2 count[c]=4`,`op[0]=a op[1]=b op[2]=3``op_size=3`ã€‚

| ç¼–å· | weight | parent | lchild | rchile | op   | code |
| ---- | ------ | ------ | ------ | ------ | ---- | ---- |
| 0    | 1      | 3      | -1     | -1     | a    | 11   |
| 1    | 2      | 3      | -1     | -1     | b    | 10   |
| 2    | 4      | 4      | -1     | -1     | c    | 0    |
| 3    | 3      | 4      | 0      | 1      | 0    |      |
| 4    | 7      | -1     | 3      | 2      | 0    |      |

#### preOrderLeaf()

è¿™ä¸ªå‡½æ•°ä¹Ÿæœ‰ä¸¤ä¸ªé‡è½½ï¼Œä¸‹é¢ä»‹ç»ä¸»è¦åŠŸèƒ½å®ç°çš„å‡½æ•°

å‚æ•°åŒ==ShowTree()==çš„æ„æ€

è¿™ä¸ªå‡½æ•°æ˜¯è¾“å‡ºå¶å­ç»“ç‚¹å¯¹åº”çš„æƒå€¼ï¼Œopå’Œcodeã€‚å…¶ä¸­çš„codeæ˜¯HFMTreeç±»ä¸­çš„ä¸€ä¸ªç§æœ‰æˆå‘˜

**map<char,string>code**ï¼šå‚¨å­˜å¯¹åº”å­—ç¬¦å¯¹åº”çš„äºŒè¿›åˆ¶ç¼–ç ï¼Œç”¨äº==encode()==å‡½æ•°ï¼Œå¯¹å­—ç¬¦ä¸²è¿›è¡Œç¼–ç 

~~~c++
void preOrderLeaf(int idx,char* op,int op_size){
		if (idx != -1 )
		{
			if(m_data[idx].lchild == -1 && m_data[idx].rchild == -1){
				for(int i = 0;i < op_size;i++){
					if(m_data[idx].op == op[i]){
						code[op[i]] = m_data[idx].code;
						if(op[i] != ' ')
							cout << left << setw(7) << op[i];
						else
							cout << setw(7) << "space";
						cout << setw(4) << m_data[idx].weight << m_data[idx].code <<endl;
						op[i] = '0';
						break;
					}
				}
			}
				
			preOrderLeaf(m_data[idx].lchild,op,op_size);
			preOrderLeaf(m_data[idx].rchild,op,op_size);
		}
	}
~~~

#### encode()

å‚æ•°è§£é‡Šï¼šéœ€è¦ç¼–ç çš„å­—ç¬¦ä¸²

~~~c++
string encode(const string str){
        string coding = "";
        for (unsigned int i = 0; i < str.length(); i++)
            coding += this->code[str.at(i)];
        return coding;
    }
~~~

#### decode()

è¿™ä¸ªå‡½æ•°æœ‰ä¸‰ä¸ªé‡è½½

**decode(const string& code)**

éœ€è¦è§£ç çš„äºŒè¿›åˆ¶ç¼–ç ï¼Œè¿”å›stringç±»å‹

~~~c++
string decode(const string& code){
		return decode(this->GetLength()-1,code);
	}
~~~

**decode(int idx, const string& code)**

idxï¼šç»“ç‚¹å¯¹åº”çš„ä¸‹æ ‡ï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦ä¸ºå¶å­ç»“ç‚¹

è¿”ä¼šstringç±»å‹

~~~c++
string decode(int idx, const string& code) {
		string result;
		//å› ä¸ºå¼•ç”¨çš„æ˜¯const stringç±»å‹ï¼Œæ‰€ä»¥è¿­ä»£å™¨è¦ä½¿ç”¨con_iterator
		string::const_iterator codeBegin = code.begin();
		string::const_iterator codeEnd = code.end();
		//åˆ¤æ–­æ˜¯å¦è§£ç å®Œæ¯•ï¼Œä»å¤´éƒ¨è§£åˆ°å°¾éƒ¨
		while (codeBegin != codeEnd) {
			codeBegin = decode(idx, codeBegin, codeEnd, result);
		}
		
		return result;
	}
~~~

**decode(int idx, string::const_iterator codeBegin, string::const_iterator codeEnd, string& result)**

resultå‚¨å­˜è§£ç ç»“æœ

è¿”å›const_iteratorç±»å‹è¿­ä»£å™¨

~~~c++
string::const_iterator decode(int idx, string::const_iterator codeBegin, string::const_iterator codeEnd, string& result) {
		if (m_data[idx].lchild == -1 && m_data[idx].rchild == -1) {
			result += m_data[idx].op; //æ‰¾åˆ°å¯¹åº”ä¸‹æ ‡ï¼Œå°±åŠ ä¸Šå…¶å¯¹åº”çš„op
			return codeBegin;
		} else {//ä¸æ˜¯å¯¹åº”ä¸‹æ ‡ï¼Œå°±ç§»åŠ¨codeBeginè¿­ä»£å™¨ç»§ç»­æŸ¥æ‰¾
			if (codeBegin != codeEnd) {
				if (*codeBegin == '1') {
					return decode(m_data[idx].lchild, next(codeBegin), codeEnd, result);
				} else if (*codeBegin == '0') {
					return decode(m_data[idx].rchild, next(codeBegin), codeEnd, result);
				}
			}
		}
		return codeBegin;
	}
~~~

### ä¸»å‡½æ•°

~~~c++
int main()
{
	string str;
	string coding = "";

	cout << "please input the str(-1 mean default):";
	getline(cin,str);//è·å–è¾“å…¥çš„ç©ºæ ¼ï¼Œåªæœ‰æ¢è¡Œæ‰ä¼šç»“æŸè¾“å…¥
	if(str == "-1")
		str = "The early bird catches the worm, but the second mouse gets the cheese";
	cout << '\n' << str << endl;

	map<char,int>count;
	int sum = 0;

	count['0'] = 0;
	
	char op[str.length()];

	for(unsigned int i = 0; i < str.length() ; i++){
		count[str.at(i)]++;
		if(count[str.at(i)] == 1){
			op[sum] = str.at(i);
			sum++;
		}
	}

	int freq[sum];
	for(int i = 0;i < sum; i++){
		freq[i] = count[op[i]];
	}

	HFMTree hfmt(sum,freq);
	hfmt.CreateHFMTree(); //åˆ›å»ºå“ˆå¤«æ›¼æ ‘
	char op1[sum];
	strcpy(op1,op);
	hfmt.ShowTree(count,op1,sum);
	cout << endl;
	strcpy(op1,op);
	hfmt.preOrderLeaf(op1,sum); //éå†å“ˆå¤«æ›¼æ ‘ï¼Œå‚æ•°å…¶å®å°±æ˜¯æ ¹èŠ‚ç‚¹çš„ä¸‹æ ‡ï¼ˆæ•°ç»„æœ€åä¸€ä¸ªæœ‰æ•ˆä½ç½®çš„ä¸‹æ ‡ï¼‰
	coding = hfmt.encode(str);
	cout << endl <<coding << endl;
	cout << endl << hfmt.decode(coding) << endl;
    cout << "\nthe str has " << str.length() - count[' '] << " letters" << endl;
	return 0;
}
~~~

### å®ç°ç»“æœ

![image-20231113235248516](D:\è½¯ä»¶\typora\Typora\image\hfm_tree\image-20231113235248516.png)

![image-20231113235305098](D:\è½¯ä»¶\typora\Typora\image\hfm_tree\image-20231113235305098.png)

## ç»“è¯­

æ€»ç»“å°±æ˜¯ï¼Œå¯¹äºæ ‘è¿™ç§ç»“æ„ï¼Œé€’å½’å¯ä»¥è§£å†³å…¶å¤§éƒ¨åˆ†é—®é¢˜ï¼Œè¿˜æ˜¯å¾—å¤šå­¦ä¹ å¤§ä½¬ä»¬çš„å·ç‹ç²¾ç¥ï¼Œè¿˜æ˜¯ä¸å¤Ÿå·ã€‚åŠ æ²¹å§ğŸ˜¤

è¿™ä¸ªå†™äº†ä¸€å¤©ï¼Œç°åœ¨å·²ç»åŠå¤œäº†ã€‚è¿™ä¸ªæ˜¯æœ€è¿‘çš„å­¦ä¹ æˆæœï¼Œå¸Œæœ›ä»¥åè¿˜ä¼šå†™å§ã€‚

## é™„å½•

~~~c++
#include<iostream>
#include<string.h>
#include<iomanip>
#include<stdlib.h>
#include<map>
using namespace std; 

#define RIGHT '0'
#define LEFT '1'
string up_right = "â”Œ";
string down_right = "â””";
string up_left = "â”";
string down_left = "â”˜";
string T_cross = "â”¤";
string line = "â”‚";

//å“ˆå¤«æ›¼æ ‘çš„èŠ‚ç‚¹
struct HFMTreeNode{
	string code;
	char op;
	int weight; //æƒå€¼
	int parent; //çˆ¶äº²ï¼ˆæ•°ç»„ä¸‹æ ‡å€¼ï¼‰
	int lchild; //å·¦å­©å­
	int rchild; //å³å­©å­
};
//å“ˆå¤«æ›¼æ ‘
class HFMTree{
private:
	HFMTreeNode* m_data;
	map<char,string>code;
	int m_length; //è®°å½•å½“å‰æ ‘æœ‰å¤šå°‘ä¸ªèŠ‚ç‚¹ã€æ•°ç»„ä¸­å¤šå°‘ä¸ªèŠ‚ç‚¹è¢«ä½¿ç”¨äº†ã€‘
	
	void SelectTwoMinValue(int& rtnIdx1, int& rtnIdx2){
		int minval1 = INT_MAX;
		int minval2 = INT_MAX;
	
		//æ‰¾æœ€å°å€¼
		for (int i = 0; i < m_length; ++i)
		{
			if (m_data[i].parent == -1) //çˆ¶æ ‡è®°æœªè¢«ä½¿ç”¨
			{
				if (minval1 > m_data[i].weight)
				{
					minval1 = m_data[i].weight; //è®°å½•æœ€å°å€¼
					rtnIdx1 = i; //è®°å½•ä¸‹æ ‡
				}
			}
		} 
	
		//æ‰¾ç¬¬äºŒä¸ªæœ€å°çš„å€¼
		for (int i = 0; i < m_length; ++i)
		{
			if (m_data[i].parent == -1 && i != rtnIdx1) //æ³¨æ„&&åçš„æ¡ä»¶ï¼Œç›®çš„æ˜¯æŠŠç¬¬ä¸€ä¸ªæ‰¾åˆ°çš„æœ€å°æƒå€¼çš„èŠ‚ç‚¹æ’é™¤
			{
				if (minval2 > m_data[i].weight)
				{
					minval2 = m_data[i].weight; //è®°å½•æœ€å°å€¼
					rtnIdx2 = i; //è®°å½•ä¸‹æ ‡
				}
			}
		}
		return;
	}
	void preOrderLeaf(int idx,char* op,int op_size){
		if (idx != -1 )
		{
			if(m_data[idx].lchild == -1 && m_data[idx].rchild == -1){
				for(int i = 0;i < op_size;i++){
					if(m_data[idx].op == op[i]){
						code[op[i]] = m_data[idx].code;
						if(op[i] != ' ')
							cout << left << setw(7) << op[i];
						else
							cout << setw(7) << "space";
						cout << setw(4) << m_data[idx].weight << m_data[idx].code <<endl;
						op[i] = '0';
						break;
					}
				}
			}
				
			preOrderLeaf(m_data[idx].lchild,op,op_size);
			preOrderLeaf(m_data[idx].rchild,op,op_size);
		}
	}

	void ShowTree(int idx,map<char,int>count,char* op,int op_size,string way){ // wayè¡¨ç¤ºè¾¾åˆ°è¯¥èŠ‚ç‚¹èµ°è¿‡çš„è·¯ï¼Œä»æ ¹å¼€å§‹ï¼Œå‘å³æ˜¯'0'ï¼Œå‘å·¦æ˜¯'1'
		if (m_data[idx].rchild != -1)
		{
			string right_way = way + RIGHT;
			ShowTree(m_data[idx].rchild,count,op,op_size, right_way);
		}
		this->m_data[idx].code = way;
		string pre;            // æ‰“å°èŠ‚ç‚¹å‰éœ€è¦è¾“å‡ºçš„å‰ç½®æ•°æ®
		if (way.length() == 0) // æ ¹èŠ‚ç‚¹ï¼Œä¸è€ƒè™‘å‰ç½®è¾“å‡ºï¼Œè¿™é‡Œè¾“å‡ºä¸€ä¸ªç©ºæ ¼
			pre = " ";
		else
		{
			pre = "   ";  // è¿™ä¸‰ä¸ªç©ºæ ¼æ¥è‡ªæ ¹èŠ‚ç‚¹é‚£ä¸€å±‚
			for (unsigned int i = 1; i < way.length(); i++)
			{
				// æŒ‰ç…§å¼‚æˆ–å…³ç³»è¡¥å…¨å‰ç½®è¾“å‡º
				if (way.at(i) != way.at(i - 1))
				{
					pre += line;
					pre += "  ";
				}
				else
				{
					pre += "   ";
				}
			}
			int l = way.length();
			// æ ¹æ®æœ€åä¸€æ¬¡è½¬å¼¯æ–¹å‘é€‰æ‹©æ•°å­—å‰é¢çš„ç¬¦å·
			if (way.at(l - 1) == '0')
				pre += up_right;
			else
				pre += down_right;
		}
		
		cout << pre << setw(2) << m_data[idx].weight;
		// æ ¹æ®å·¦å³å­æ ‘æƒ…å†µä¸ºä¸‹ä¸€å±‚ç•™ä¸‹åˆ†å‰æ ‡å¿—
		if (m_data[idx].lchild != -1 && m_data[idx].rchild != -1)
			cout << T_cross;
		else if (m_data[idx].lchild != -1 && m_data[idx].rchild == -1)
			cout << up_left;
		else if (m_data[idx].lchild == -1 && m_data[idx].rchild != -1)
			cout << down_left;
		else{
			for(int i = 0; i < op_size ; i++){
				if(m_data[idx].weight == count[op[i]]){
					m_data[idx].op = op[i];
					op[i] = '0';
					break;
				}
			}
			if(m_data[idx].op == ' ')
				cout << " " << "space";
			else
				cout << " " << m_data[idx].op;
		}
			 
		cout << endl;
		
		if (m_data[idx].lchild != -1)
		{
			string left_way = way + LEFT;
			ShowTree(m_data[idx].lchild,count,op,op_size, left_way);
		}
	}
	
	string decode(int idx, const string& code) {
		string result;
		
		string::const_iterator codeBegin = code.begin();
		string::const_iterator codeEnd = code.end();
		
		while (codeBegin != codeEnd) {
			codeBegin = decode(idx, codeBegin, codeEnd, result);
		}
		
		return result;
	}
	string::const_iterator decode(int idx, string::const_iterator codeBegin, string::const_iterator codeEnd, string& result) {
		if (m_data[idx].lchild == -1 && m_data[idx].rchild == -1) {
			result += m_data[idx].op;
			return codeBegin;
		} else {
			if (codeBegin != codeEnd) {
				if (*codeBegin == '1') {
					return decode(m_data[idx].lchild, next(codeBegin), codeEnd, result);
				} else if (*codeBegin == '0') {
					return decode(m_data[idx].rchild, next(codeBegin), codeEnd, result);
				}
			}
		}
		
		return codeBegin;
	}
	
public:
	~HFMTree(){ //ææ„å‡½æ•°
		delete[] m_data;
	}
	HFMTree(int nodecount, int* pweight){
		code['0'] = "";
		m_length = nodecount; //èŠ‚ç‚¹ä¸ªæ•°
		int iMaxNodeCount = 2 * m_length - 1; //å“ˆå¤«æ›¼æ ‘çš„èŠ‚ç‚¹æ€»æ•°æ˜¯2n-1ï¼ˆnä»£è¡¨å“ˆå¤«æ›¼æ ‘çš„å¶å­èŠ‚ç‚¹æ•°é‡ï¼‰
		m_data = new HFMTreeNode[iMaxNodeCount]; //2n-1ä¸ªèŠ‚ç‚¹çš„å“ˆå¤«æ›¼æ•°ç»„
	
		for (int i = 0; i < iMaxNodeCount; ++i)
		{
			//-1æ ‡è®°æœªè¢«ä½¿ç”¨
			m_data[i].code = "";
			m_data[i].op = '0';
			m_data[i].parent = -1;
			m_data[i].lchild = -1;
			m_data[i].rchild = -1;
		} 
		for (int i = 0; i < m_length; ++i)
		{
			m_data[i].weight = pweight[i];
		}
	}
	void CreateHFMTree(){
		int idx1 = 0;
		int idx2 = 0;
		
		int iMaxNodeCount = 2 * m_length - 1; //2n-1æ˜¯æ•´ä¸ªå“ˆå¤«æ›¼æ ‘çš„èŠ‚ç‚¹æ•°é‡
		int initlength = m_length;
		for (int i = initlength; i < iMaxNodeCount; ++i)
		{
			SelectTwoMinValue(idx1, idx2);
			m_data[i].weight = m_data[idx1].weight + m_data[idx2].weight; //æ–°èŠ‚ç‚¹çš„æƒå€¼ç­‰äºå·¦å³å­©å­
			m_data[i].lchild = idx1;
			m_data[i].rchild = idx2;
			m_data[i].op = '0';
			m_data[idx1].parent = i;
			m_data[idx2].parent = i;

			m_length++; //SelectTwoMinValue()å‡½æ•°è¦ç”¨åˆ°è¯¥å€¼
		}
		return;
	}
	
	int GetLength(){
		return m_length;
	}
	
	void preOrderLeaf(char* op,int op_size){
		preOrderLeaf(this->GetLength()-1,op,op_size);
	}
	void ShowTree(map<char,int>count,char* op,int op_size){
		ShowTree(this->GetLength()-1,count,op,op_size,"");
	}

	string encode(const string str){
        string coding = "";
        for (unsigned int i = 0; i < str.length(); i++)
            coding += this->code[str.at(i)];
        return coding;
    }
	string decode(const string& code){
		return decode(this->GetLength()-1,code);
	}
};



int main()
{
	string str;
	string coding = "";

	cout << "please input the str(-1 mean default):";
	getline(cin,str);
	if(str == "-1")
		str = "The early bird catches the worm, but the second mouse gets the cheese";
	cout << '\n' << str << endl;

	map<char,int>count;
	int sum = 0;

	count['0'] = 0;
	
	char op[str.length()];

	for(unsigned int i = 0; i < str.length() ; i++){
		count[str.at(i)]++;
		if(count[str.at(i)] == 1){
			op[sum] = str.at(i);
			sum++;
		}
	}

	int freq[sum];
	for(int i = 0;i < sum; i++){
		freq[i] = count[op[i]];
	}

	HFMTree hfmt(sum,freq);
	hfmt.CreateHFMTree(); //åˆ›å»ºå“ˆå¤«æ›¼æ ‘
	char op1[sum];
	strcpy(op1,op);
	hfmt.ShowTree(count,op1,sum);
	cout << endl;
	strcpy(op1,op);
	hfmt.preOrderLeaf(op1,sum); //éå†å“ˆå¤«æ›¼æ ‘ï¼Œå‚æ•°å…¶å®å°±æ˜¯æ ¹èŠ‚ç‚¹çš„ä¸‹æ ‡ï¼ˆæ•°ç»„æœ€åä¸€ä¸ªæœ‰æ•ˆä½ç½®çš„ä¸‹æ ‡ï¼‰
	coding = hfmt.encode(str);
	cout << endl <<coding << endl;
	cout << endl << hfmt.decode(coding) << endl;
    cout << "\nthe str has " << str.length() - count[' '] << " letters" << endl;
	return 0;
}

/***
 * â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â” â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â” â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â” â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
 * â”‚Escâ”‚   â”‚ F1â”‚ F2â”‚ F3â”‚ F4â”‚ â”‚ F5â”‚ F6â”‚ F7â”‚ F8â”‚ â”‚ F9â”‚F10â”‚F11â”‚F12â”‚ â”‚P/Sâ”‚S Lâ”‚P/Bâ”‚  â”Œâ”    â”Œâ”    â”Œâ”
 * â””â”€â”€â”€â”˜   â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜ â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜ â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜ â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜  â””â”˜    â””â”˜    â””â”˜
 * â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â” â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
 * â”‚~ `â”‚! 1â”‚@ 2â”‚# 3â”‚$ 4â”‚% 5â”‚^ 6â”‚& 7â”‚* 8â”‚( 9â”‚) 0â”‚_ -â”‚+ =â”‚ BacSp â”‚ â”‚Insâ”‚Homâ”‚PUpâ”‚ â”‚N Lâ”‚ / â”‚ * â”‚ - â”‚
 * â”œâ”€â”€â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤ â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
 * â”‚ Tab â”‚ Q â”‚ W â”‚ E â”‚ R â”‚ T â”‚ Y â”‚ U â”‚ I â”‚ O â”‚ P â”‚{ [â”‚} ]â”‚ | \ â”‚ â”‚Delâ”‚Endâ”‚PDnâ”‚ â”‚ 7 â”‚ 8 â”‚ 9 â”‚   â”‚
 * â”œâ”€â”€â”€â”€â”€â”´â”¬â”¬â”€â”€â”´â”¬â”€â”€â”´â”¬â”€â”€â”´â”¬â”€â”€â”´â”¬â”€â”€â”´â”€â”€â”´â”¬â”€â”€â”´â”¬â”€â”€â”´â”¬â”€â”€â”´â”¬â”€â”€â”´â”¬â”€â”€â”´â”¬â”€â”€â”´â”€â”€â”€â”€â”€â”¤ â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜ â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤ + â”‚
 * â”‚ Caps â”‚ A â”‚ S â”‚ D â”‚ F â”‚ G â”‚ H â”‚ J â”‚ K â”‚ L â”‚: ;â”‚" 'â”‚ Enter  â”‚               â”‚ 4 â”‚ 5 â”‚ 6 â”‚   â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”¬â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”Œâ”€â”€â”€â”     â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
 * â”‚ Shift  â”‚ Z â”‚ X â”‚ C â”‚ V â”‚ B â”‚ N â”‚ M â”‚< ,â”‚> .â”‚? /â”‚  Shift   â”‚     â”‚ â†‘ â”‚     â”‚ 1 â”‚ 2 â”‚ 3 â”‚   â”‚
 * â”œâ”€â”€â”€â”€â”€â”¬â”€â”€â”´â”€â”¬â”€â”´â”€â”€â”¬â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”¬â”´â”€â”€â”€â”¼â”€â”€â”€â”´â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¤ â”Œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â” â”œâ”€â”€â”€â”´â”€â”€â”€â”¼â”€â”€â”€â”¤ Eâ”‚â”‚
 * â”‚ Ctrlâ”‚    â”‚Alt â”‚         Space         â”‚ Altâ”‚    â”‚    â”‚Ctrlâ”‚ â”‚ â† â”‚ â†“ â”‚ â†’ â”‚ â”‚   0   â”‚ . â”‚â†â”€â”˜â”‚
 * â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
 */
~~~

